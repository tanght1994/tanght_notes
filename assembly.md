123123123

```
push $8
movl %esp, %ebp
subl $4, %esp
movl $8, (%esp)
```



r:查看、修改寄存器的值。直接输入`r`，会显示出所有寄存器的内容。输入`r ax`可以修改ax的值。

d:查看内存的值。直接输入`d`，会显示所有内存的值。输入`d 段地址:偏移地址`查看指定地址的内存。`d 地址 长度`可以指定查看的长度

e:修改内存中的数据 `e 2100:1000 AA BB` 将AABBH这16位放入2100:1000处

u:以汇编语句的格式，查看内存中的数据，类似d

a:以汇编的形式，向当前地址写入命令。

t：执行一条指令。肯定是执行`CS:IP`指向的指令啊，这是必须的。

g: `g 0014`程序直接运行到IP为0014的代码，中间就不单步暂停了



定位指令：CS+IP

定位内存中的数据：DS+偏移量，`mov al, [8]`的意思是，将`DS:8`这个地址，一个字节长度的数据，放入al中。所以想要取内存中的数据，不仅要维护偏移地址（汇编代码中的[8]），还要提前维护DS寄存器。DS寄存器必须由通用寄存器赋值，不能直接赋值。

注意：用`[]`表示偏移地址。DS不能直接接收数据，必须先给AX，再由AX给DS。





```shell
# 通用寄存器
AX AL AH   
BX BL BH   用BX表示偏移地址mov ax [bx]
CX CL CH   loop会查看cx是否为0
DX DL DH

# 指令相关  CS:IP这个地址，就是即将要执行的语句
# 语句执行的时候，IP自动变化，自动维护，不用程序员维护
CS # 指令段寄存器
IP # 指令偏移寄存器

# 数据相关  mov ax, [5]   [5]代表DS:0005H这个地址
DS #数据段寄存器
ES #附加段，与DS功能类似

# 栈相关   SS:SP这个地址，就是栈顶元素
# push和pop语句执行的时候，SP自动变化，自动维护，不用程序员维护
SS  # 栈顶，段地址
SP  # 栈顶，偏移地址


# 怕BX不够用，又多了两个寄存器来辅助，当然，这两个寄存器的功能跟BX是一样的
SI
DI

# 寻址只能用以下寄存器
[bx]
[si]  # 一般用于复制，源
[di]  # 一般用于复制，目标
[bp]  # 一般用于栈中的寻址，因为bp前面默认添加的是ss
```





debug与masm的区别

```
# 在debug中这样写，意味着，将DS:0这个地址的内容拷贝到ax中
mov ax,[0]

# 在txt中这样写，意味着，将0这个数值拷贝到ax中
# masm编译这个txt的时候，将[]去掉了
mov ax,[0]

# 如何在.asm中表示内存的地址呢？
mov bx，0H
mov ax,[bx]  # 这个就相当于mov ax,[0]了，有些麻烦但是没办法

# 加上段地址之后，就可以直接使用数字而不以来bx了
mov ax, ds:[1]   可以实现将ds:0001的数据传送到ax
mov ax, [1]      直接将1这个数字放入到ax
```

mov指令

`mov 目标，源`

移动1字节还是2字节由源的长度决定  `mov ax, [0]`移动1字节，因为内存地址DS:0001是1字节。`mov ax, bx`移动2字节，因为bx是2字节。

loop指令：

1.先cx = cx -1

2.判断cx是否为0

3.根据上步的判断，决定是否跳转到loop的标签处



汇编.asm中，数值不能以字母开头，比如说不能`mov ax AABBH`

如何解决上述问题？在前面加个0就好了`mov ax 0AABBH`



```assembly
assume cs:codesg

codesg segment
		dw 0123H, 0456H, 0AABBH
start:  mov ax, 2000H
        mov ds, ax
        mov ax, 2H
        mov cx, 9H
    s:  add ax, ax
        loop s
        mov bx, 0H
        mov [bx], ax
        mov [bx], ax
        mov ax, 4c00h
        int 21h
codesg ends
end start
```

上述代码，在代码段的开头先定义了3个16位的数据，但是由于我们指定了`end start`，所以编译器会将IP寄存器的值修改为start这个标签所在的位置，而不是0。所以尽管CS寄存器的值为`dw`这个地址，但是我们的指令指针会从start处开始。

如果不指定start，则IP寄存器默认为0，就会从`dw`这几个数字处开始执行，CPU会将这几个数字翻译为指令，肯定会出错了。

如果不指定start，但是代码段的最开始就是真正的指令的话，那也不会出错。



错误：

`assume cs:codesg`的意思是：将`cs`寄存器的内容，设置为`codesg`标签处的地址。也就是说设置一下代码段的位置。

`assume ss:abc`的意思是：同上，设置栈段

`assume ds:def`的意思是：同上，设置数据段

错误：assume并不负责设置，只是一个说明作用





在没有寄存器出现的指令中(如`mov ds:[bx] 1H`)，需要用关键字指明需要操作的数据的长度。如果指令中有寄存器出现，则长度以寄存器为准

word ptr：16位

byte ptr：8位
