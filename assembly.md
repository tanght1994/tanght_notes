# 汇编类型

GNU汇编使用 AT&T 样式的语法，其中源和目的操作数正好与 Intel 的格式相反

# 啦啦啦

```
push $8
movl %esp, %ebp
subl $4, %esp
movl $8, (%esp)
```



r:查看、修改寄存器的值。直接输入`r`，会显示出所有寄存器的内容。输入`r ax`可以修改ax的值。

d:查看内存的值。直接输入`d`，会显示所有内存的值。输入`d 段地址:偏移地址`查看指定地址的内存。`d 地址 长度`可以指定查看的长度

e:修改内存中的数据 `e 2100:1000 AA BB` 将AABBH这16位放入2100:1000处

u:以汇编语句的格式，查看内存中的数据，类似d

a:以汇编的形式，向当前地址写入命令。

t：执行一条指令。肯定是执行`CS:IP`指向的指令啊，这是必须的。

g: `g 0014`程序直接运行到IP为0014的代码，中间就不单步暂停了



定位指令：CS+IP

定位内存中的数据：DS+偏移量，`mov al, [8]`的意思是，将`DS:8`这个地址，一个字节长度的数据，放入al中。所以想要取内存中的数据，不仅要维护偏移地址（汇编代码中的[8]），还要提前维护DS寄存器。DS寄存器必须由通用寄存器赋值，不能直接赋值。

注意：用`[]`表示偏移地址。DS不能直接接收数据，必须先给AX，再由AX给DS。



```shell
# 通用寄存器
AX AL AH   
BX BL BH   用BX表示偏移地址mov ax [bx]
CX CL CH   loop会查看cx是否为0
DX DL DH

# 指令相关  CS:IP这个地址，就是即将要执行的语句
# 语句执行的时候，IP自动变化，自动维护，不用程序员维护
CS # 指令段寄存器
IP # 指令偏移寄存器

# 数据相关  mov ax, [5]   [5]代表DS:0005H这个地址
DS #数据段寄存器
ES #附加段，与DS功能类似

# 栈相关   SS:SP这个地址，就是栈顶元素
# push和pop语句执行的时候，SP自动变化，自动维护，不用程序员维护
SS  # 栈顶，段地址
SP  # 栈顶，偏移地址


# 怕BX不够用，又多了两个寄存器来辅助，当然，这两个寄存器的功能跟BX是一样的
SI
DI

# 寻址只能用以下寄存器
[bx]
[si]  # 一般用于复制，源
[di]  # 一般用于复制，目标
[bp]  # 一般用于栈中的寻址，因为bp前面默认添加的是ss
```



debug与masm的区别

```
# 在debug中这样写，意味着，将DS:0这个地址的内容拷贝到ax中
mov ax,[0]

# 在txt中这样写，意味着，将0这个数值拷贝到ax中
# masm编译这个txt的时候，将[]去掉了
mov ax,[0]

# 如何在.asm中表示内存的地址呢？
mov bx，0H
mov ax,[bx]  # 这个就相当于mov ax,[0]了，有些麻烦但是没办法

# 加上段地址之后，就可以直接使用数字而不以来bx了
mov ax, ds:[1]   可以实现将ds:0001的数据传送到ax
mov ax, [1]      直接将1这个数字放入到ax
```

mov指令

`mov 目标，源`

移动1字节还是2字节由源的长度决定  `mov ax, [0]`移动1字节，因为内存地址DS:0001是1字节。`mov ax, bx`移动2字节，因为bx是2字节。

loop指令：

1.先cx = cx -1

2.判断cx是否为0

3.根据上步的判断，决定是否跳转到loop的标签处



汇编.asm中，数值不能以字母开头，比如说不能`mov ax AABBH`

如何解决上述问题？在前面加个0就好了`mov ax 0AABBH`



```assembly
assume cs:codesg

codesg segment
		dw 0123H, 0456H, 0AABBH
start:  mov ax, 2000H
        mov ds, ax
        mov ax, 2H
        mov cx, 9H
    s:  add ax, ax
        loop s
        mov bx, 0H
        mov [bx], ax
        mov [bx], ax
        mov ax, 4c00h
        int 21h
codesg ends
end start
```

上述代码，在代码段的开头先定义了3个16位的数据，但是由于我们指定了`end start`，所以编译器会将IP寄存器的值修改为start这个标签所在的位置，而不是0。所以尽管CS寄存器的值为`dw`这个地址，但是我们的指令指针会从start处开始。

如果不指定start，则IP寄存器默认为0，就会从`dw`这几个数字处开始执行，CPU会将这几个数字翻译为指令，肯定会出错了。

如果不指定start，但是代码段的最开始就是真正的指令的话，那也不会出错。



`assume cs:codesg`的意思是：将`cs`寄存器的内容，设置为`codesg`标签处的地址。也就是说设置一下代码段的位置。

`assume ss:abc`的意思是：同上，设置栈段

`assume ds:def`的意思是：同上，设置数据段

错误：assume并不负责设置，只是一个说明作用



在没有寄存器出现的指令中(如`mov ds:[bx] 1H`)，需要用关键字指明需要操作的数据的长度。如果指令中有寄存器出现，则长度以寄存器为准

word ptr：16位

byte ptr：8位



# 地址

```
地址00 8位
地址01 8位
地址02 8位
地址03 8位
取地址00中的数据,会取到8位数据(1个字节)
如果这个数据(8位)被解释为数字的话,那么00这个地址可以表示 0-255 中任意一个数字,(0x00-0xFF 中任意一个数字)
重点要记住,一个单独的地址,储存的是8位数据,而不是1位数据!!!
```

实战

```
movl %edi, -20(%rbp) 如何理解?

1.先理解-20(%rbp)
假设当前rbp中的数据是数字100,那么用100替换%rbp
-20(%rbp) -> -20(100) -> -20+100 -> 80
最终 -20(%rbp) 就代表 80 这个数学数字
所以 movl %edi, -20(%rbp) 可以转换为 movl %edi, (80

2.再理解 movl %edi, 80
假设edi中的数据为数字200,那么用200替换%edi
movl %edi, 80  ->  movl 200, 80
意思就是将地址200处的数据复制到地址80处
movl中的l表示数据的长度,l代表32位(4字节)
所以最终的解释就是,将4个地址(80 81 82 83)的内容(共32位,4字节),复制到(200 201 202 203)这4个地址处
80 81 82 83 -> 200 201 202 203
80 -> 200
81 -> 201
82 -> 202
83 -> 203

```

# 指令长度

```
movb 传送8位
movw 传送16位
movl 传送32位
movq 传送64位

rax 64位寄存器
eax 32位寄存器
ax 16位寄存器
ah 16位寄存器的高8位
al 16位寄存器的低8位
```

# 函数调用

```
call的原理,将下一条指令的地址入栈，将被call函数的第一条指令的地址赋给程序计数器
ret的原理:栈弹出，将弹出的数据赋给程序计数器

调用者的工作：
0.将自己需要的寄存器入栈(保存现场)，因为子函数可能会修改寄存器
1.将需要传递给被调用函数的参数放到合适的寄存器或栈中
2.将下一条代码的地址入栈
3.设置程序计数器为被调用函数的第一条代码的地址
call指令就是执行2和3

被调用者的工作：
0.如果需要修改bp指针，则将当前的bp指针(上一个函数的bp指针)入栈，等此函数结束的时候，再给人家的bp指针恢复原状
1.从合适的寄存器或者栈的合适位置取到参数，进行自己的逻辑
2.如果bp指针被修改过，此时要"栈弹出"，将弹出的数据赋值给bp
3.栈弹出，将弹出的数据赋给程序计数器
ret指令就是执行3
```

