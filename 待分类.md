# ES

## ES写入过程

123

## ES查询过程

123

## MySQL数据导入ES

mysql binlog

# REDIS

## REDIS热KEY

123

## REDIS穿透

123

## REDIS雪崩

123

## REDIS过期删除策略

123

## REDIS过期回调

123

# GO

## GO如何限制协程数量

- 通过带缓冲的channel，在启动goroutine之前，向channel中发送一个数据，如果被阻塞住了，说明数量到达上限，就在这里阻塞着就好了，什么时候不阻塞了，什么时候在运行goroutine。goroutine结束时，记得从channel中读出一个数据，给其它goroutine机会来运行。
- 协程池(ants/)

## goroutine调度原理

123

# 延时队列

## redis

实现方式：

1. 将延时数据放入zset中，score为未来的时间戳
2. 另一个服务循环执行`ZRANGEBYSCORE your_delay_zset [0 [当前时间戳 LIMIT 0 100`来获取已经到达执行时间的数据，并将这些数据从redis中删除，获取与删除必须时原子操作。
3. 处理获取到的任务，可以直接处理也可以将其发送到消息队列。

缺点：

延时队列的大小受redis限制，受限于物理机的内存条的大小

优点：

可以修改或删除已经存在的延时任务

```lua
local data = redis.call('ZRANGEBYSCORE', KEYS[1], 0, redis.call('TIME')[1], 'LIMIT', '0', '1000')
for _, v in pairs(data) do
	redis.call('ZREM',KEYS[1], v)
end
return data
```

## kafka

实现方式：

创建多个类型的topic，如1S、60S、10m、30m、1h、1d等等

事件产生时，根据需要延时的时长，放到对应的topic中

每个topic用一个循环线程来获取数据

# Kafka

数据文件结构

topic由多个partition组成，partition由多个segment组成（假如1个segment最大1G，那么如果partition大小为5G的话，就有5个segment），segment由000000000.index和00000000.log文件组成
